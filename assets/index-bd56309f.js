(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const d of i.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&n(d)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();class f{constructor(e,t,n){this.rect=n,this.identifier=e,this.origin=t}containsPoint(e){return this.rect.containsPoint(e)}containsNode(e){return e instanceof f?this.rect.containsShape(e.rect):this.rect.containsShape(e.ellipse)}toString(){return"An atom representing the proposition: "+this.identifier+" and Boundary box of: "+this.rect.toString()}}class l{constructor(e,t){this.x=e??0,this.y=t??0}set(e,t){this.x=e,this.y=t}toString(){return"X: "+this.x+", Y: "+this.y}}class g{constructor(e,t,n){this.startVertex=e,this.width=t,this.height=n}getCorners(){const e=[this.startVertex];return e.push(new l(this.startVertex.x+this.width,this.startVertex.y)),e.push(new l(this.startVertex.x+this.width,this.startVertex.y+this.height)),e.push(new l(this.startVertex.x,this.startVertex.y+this.height)),e}containsPoint(e){const t=this.getCorners();return t[0].x<=e.x&&t[1].x>=e.x&&t[1].y<=e.y&&t[2].y>=e.y}overlaps(e){if(e instanceof g)return this.checkHorizontalEdgeOverlap(e)&&e.checkVerticalEdgeOverlap(this)?!0:!!(this.checkVerticalEdgeOverlap(e)&&e.checkHorizontalEdgeOverlap(this));for(let t=0;t<4;t++)if(e.containsPoint(this.getCorners()[t]))return!0;return!1}checkHorizontalEdgeOverlap(e){const t=this.getCorners(),n=e.getCorners();return t[0].y<=n[0].y&&t[2].y>=n[0].y?!0:t[0].y<=n[2].y&&t[2].y>=n[2].y}checkVerticalEdgeOverlap(e){const t=this.getCorners(),n=e.getCorners();return t[0].x<=n[0].x&&t[1].x>=n[0].x?!0:t[0].x<=n[1].x&&t[1].x>=n[1].x}containsShape(e){if(e instanceof g){const t=e.getCorners();return this.containsPoint(t[0])&&this.containsPoint(t[2])}else{for(let t=0;t<4;t++)if(!this.containsPoint(e.getWidestCoordinates()[t]))return!1;return!0}}toString(){return`A rectangle with
Top Left Vertex at: `+this.startVertex.toString()+", Width: "+this.width+", Height: "+this.height}}class y{constructor(e,t,n){this.center=e??new l,this.radiusX=t??0,this.radiusY=n??0;const r=new l(this.center.x-this.radiusX,this.center.y-this.radiusY);this.boundingBox=new g(r,this.radiusX*2,this.radiusY*2)}toString(){return"An ellipse with Center at: "+this.center.toString()+`, 
Horizontal Radius of: `+this.radiusX+`, 
Vertical Radius of: `+this.radiusY+`, 
Bounding box: `+this.boundingBox.toString()}containsPoint(e){return Math.ceil(Math.pow(e.x-this.center.x,2)/Math.pow(this.radiusX,2)+Math.pow(e.y-this.center.y,2)/Math.pow(this.radiusY,2))<=1}overlaps(e){if(e instanceof g){for(let t=0;t<4;t++)if(this.containsPoint(e.getCorners()[t]))return!0;return!1}else{if(this.boundingBox.overlaps(e.boundingBox)){const t=e.getEllipsePoints();for(let n=0;n<t.length;n++)if(this.containsPoint(t[n]))return!0}return!1}}containsShape(e){if(e instanceof g){for(let t=0;t<4;t++)if(!this.containsPoint(e.getCorners()[t]))return!1;return!0}else if(e instanceof y){const t=e.getWidestCoordinates();for(let n=0;n<4;n++)if(!this.containsPoint(t[n]))return!1;return!0}throw Error("Invalid Shape passed to containsShape, must be a Rectangle | Ellipse")}getWidestCoordinates(){return[new l(this.center.x,this.center.y-this.radiusY),new l(this.center.x+this.radiusX,this.center.y),new l(this.center.x,this.center.y+this.radiusY),new l(this.center.x-this.radiusX,this.center.y)]}getEllipsePoints(){const e=[],t=this.radiusX/15;e[0]=this.getWidestCoordinates()[3];let n,r;for(let i=1;i<64;i++)i<33?(n=e[i-1].x+t,r=this.getCurvePoint(n,1)):(n=e[i-1].x-t,r=this.getCurvePoint(n,-1)),e[i]=new l(n,r);return e}getCurvePoint(e,t){return t*this.radiusY*Math.sqrt(1-Math.pow((e-this.center.x)/this.radiusX,2))+this.center.y}}class a{constructor(e,t){this.ellipse=e??new y,this.children=t??[]}getCurrentCut(e){for(let t=0;t<this.children.length;t++){const n=this.children[t];if(n instanceof a&&this.children[t].containsNode(e))return n.getCurrentCut(e)}return this}containsPoint(e){return this.ellipse===null?!0:this.ellipse.containsPoint(e)}containsNode(e){if(this.ellipse===null)return!0;if(e instanceof f)return this.ellipse.containsShape(e.rect);if(e instanceof a)return this.ellipse.containsShape(e.ellipse);throw Error("containsNode expected AtomNode or CutNode")}remove(e){if(this.containsPoint(e)){let t=!0;for(let n=0;n<this.children.length;n++)if(this.children[n].containsPoint(e))return t=!1,this.children[n]instanceof a?this.children[n].remove(e):(this.children=this.children.splice(n,1),!0);if(t)return!0}return!1}toString(){let e;return this.ellipse===null?e="Sheet of Assertion of the AEG Tree":e=`A cut node with boundary box of 
`+this.ellipse.toString(),this.children.length>0&&(e+=`, 
With nested nodes: `+this.children.toString()),e}toFormulaString(){let e="";for(const t of this.children)t instanceof f?e+=t.identifier:t instanceof a&&(e+=t.toFormulaString()),e+=" ";return e=e.slice(0,-1),this.ellipse===null?e="["+e+"]":e="("+e+")",e}}class z{constructor(e){this.sheet=e??new a,this.sheet.ellipse=null}verify(){return this.verifyAEG(this.sheet)}verifyAEG(e){for(let t=0;t<e.children.length;t++){if(!e.containsNode(e.children[t]))return!1;for(let n=t+1;n<e.children.length;n++)if(this.overlaps(e.children[t],e.children[n]))return!1}for(let t=0;t<e.children.length;t++)if(e.children[t]instanceof a&&!this.verifyAEG(e.children[t]))return!1;return!0}canInsert(e){const t=this.sheet.getCurrentCut(e);for(let n=0;n<t.children.length;n++)if(this.overlaps(e,t.children[n]))return!1;return!0}insert(e){if(!this.canInsert(e))throw new Error("Insertion failed. "+e+" had a collision.");const t=this.sheet.getCurrentCut(e),n=[...t.children];if(t.children.push(e),e instanceof a)for(let r=0;r<n.length;r++)e.containsNode(n[r])&&(e.children.push(n[r]),t.children=t.children.splice(r,1))}remove(e){this.sheet.remove(e)}overlaps(e,t){let n,r;return e instanceof f?t instanceof f?e.rect.overlaps(t.rect):(n=t.ellipse,e.rect.overlaps(n)):t instanceof f?(n=e.ellipse,n.overlaps(t.rect)):(n=e.ellipse,r=t.ellipse,n.overlaps(r))}toString(){return this.sheet.toFormulaString()}}const o=document.getElementById("canvas"),X=o.getContext("2d"),G=document.getElementById("showRect"),D=document.getElementById("mode");if(X===null)throw Error("2d rendering context not supported");const h=X;let Y,R;function q(s,e){const t=s.x-e.x,n=s.y-e.y;return Math.sqrt(t*t+n*n)}function j(s,e){const t=new l((e.x-s.x)/2+s.x,(e.y-s.y)/2+s.y),n=s.x-e.x,r=s.y-e.y,i=Math.abs(n),d=Math.abs(r);let E,C;if(D.value==="circumscribed"){const V=Math.floor(q(t,e));C=Math.floor(V*(d/i)),E=Math.floor(V*(i/d))}else E=i/2,C=d/2;G.checked&&(h.beginPath(),h.rect(s.x,s.y,-n,-r),h.stroke());const I=new y(t,E,C);return u.canInsert(new a(I))?h.strokeStyle="#00FF00":h.strokeStyle="#FF0000",h.beginPath(),h.ellipse(t.x,t.y,E,C,0,0,2*Math.PI),h.stroke(),I}function U(){o.addEventListener("mousedown",F)}function F(s){Y=new l(s.clientX,s.clientY),o.addEventListener("mousemove",M),o.addEventListener("mouseup",A),o.addEventListener("mouseout",S)}function M(s){const e=new l(s.clientX,s.clientY);h.clearRect(0,0,o.width,o.height),v(u.sheet),R=j(Y,e)}function A(){const s=new a(R);u.canInsert(s)&&u.insert(s),console.log(u.toString()),o.removeEventListener("mousemove",M),o.removeEventListener("mouseup",A),o.removeEventListener("mouseout",S),h.clearRect(0,0,o.width,o.height),v(u.sheet)}function S(){o.removeEventListener("mousemove",M),o.removeEventListener("mouseup",A),o.removeEventListener("mouseout",S),h.clearRect(0,0,o.width,o.height),v(u.sheet)}function K(){o.removeEventListener("mousedown",F)}const c=document.getElementById("canvas"),T=c.getContext("2d");if(T===null)throw Error("2d rendering context not supported");const x=T;let m,w;function Z(){window.addEventListener("keypress",$)}function $(s){Q(s.key)&&(c.addEventListener("mousedown",H),w=s.key)}function H(s){const e=new l(s.clientX,s.clientY);m=e,x.fillText(w,e.x,e.y),x.stroke(),c.addEventListener("mousemove",b),c.addEventListener("mouseup",B),c.addEventListener("mouseout",O)}function b(s){m=new l(s.clientX,s.clientY),x.clearRect(0,0,c.width,c.height),v(u.sheet),x.fillText(w,m.x,m.y),x.stroke()}function B(){const s=x.measureText(w),e=new g(new l(m.x,m.y-s.actualBoundingBoxAscent),s.width,s.fontBoundingBoxDescent+s.actualBoundingBoxAscent),t=new f(w,m,e);u.insert(t),console.log(u.toString()),c.removeEventListener("mousemove",b),c.removeEventListener("mouseup",B),c.removeEventListener("mouseOut",O)}function O(){c.removeEventListener("mousemove",b),c.removeEventListener("mouseup",B),c.removeEventListener("mouseOut",O),x.clearRect(0,0,c.width,c.height),v(u.sheet)}function J(){c.removeEventListener("mousedown",H),window.removeEventListener("keydown",$)}function Q(s){return!!new RegExp(/^[A-Za-z]$/).test(s)}const k=document.getElementById("canvas");k.width=window.innerWidth;k.height=window.innerHeight;const W=k.getContext("2d");if(W===null)throw Error("2d rendering context not supported");const p=W;p.font="35pt arial";const _=document.getElementById("graphString");let L=!1,P=!1;const u=new z;window.atomMode=ee;window.ellipseMode=N;function N(){L=!0,U(),P&&(J(),P=!1)}function ee(){P=!0,Z(),L&&(K(),L=!1)}function v(s){_.innerHTML=u.toString();for(let e=0;s.children.length>e;e++)s.children[e]instanceof f?te(s.children[e]):v(s.children[e]);s.ellipse instanceof y&&(p.strokeStyle="#000000",p.beginPath(),p.ellipse(s.ellipse.center.x,s.ellipse.center.y,s.ellipse.radiusX,s.ellipse.radiusY,0,0,2*Math.PI),p.stroke())}function te(s){p.fillText(s.identifier,s.origin.x,s.origin.y),p.stroke()}
